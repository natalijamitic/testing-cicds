name: Promote tenant to existing release (same channel)

on:
  workflow_dispatch:
    inputs:
      channel:
        description: "Environment/channel (same-channel only)"
        type: choice
        options: [dev, staging, production]
        default: dev
      version:
        description: "X.Y.Z to promote (must already exist under the chosen channel)"
        type: string
        required: true
      tenants:
        description: "Comma-separated tenants (e.g., csu or default,csu)"
        type: string
        default: "csu"

permissions:
  contents: write

jobs:
  promote:
    runs-on: ubuntu-latest

    concurrency:
      group: promote-sync-${{ inputs.channel }}
      cancel-in-progress: false

    env:
      CH:  ${{ inputs.channel }}
      VER: ${{ inputs.version }}
      RAW_TENANTS: ${{ inputs.tenants }}

    steps:
      - name: Show inputs
        run: |
          echo "channel: ${{ inputs.channel }}"
          echo "version: ${{ inputs.version }}"
          echo "tenants: ${{ inputs.tenants }}"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all refs
        run: git fetch --all --tags --force --quiet

      # OPTIONAL: .github/promotion-allowlist.json => { "users": ["octocat","alice"] }
      - name: Guard allowlisted users only
        if: ${{ hashFiles('.github/promotion-allowlist.json') != '' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const p = path.join(process.env.GITHUB_WORKSPACE,'.github','promotion-allowlist.json');
            const actor = context.actor.toLowerCase();
            try {
              const { users=[] } = JSON.parse(fs.readFileSync(p,'utf8'));
              const ok = users.map(u=>String(u).toLowerCase()).includes(actor);
              if (!ok) core.setFailed(`User @${actor} is not in promotion allowlist.`);
              else core.info(`@${actor} is allowed to promote.`);
            } catch (e) {
              core.setFailed(`Invalid promotion-allowlist.json: ${e.message}`);
            }

      - name: Validate tenants (single source of truth) + channel guard
        id: tenants
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs'), path = require('path');
            const cfg = path.join(process.env.GITHUB_WORKSPACE,'.github','tenants.json');
            if (!fs.existsSync(cfg)) { core.setFailed(`Missing ${cfg}`); return; }
            const {tenants: allowed} = JSON.parse(fs.readFileSync(cfg,'utf8'));
            const raw = (process.env.RAW_TENANTS||'').replace(/\s+/g,'').toLowerCase();
            if (!raw) { core.setFailed('No tenants provided'); return; }
            let req = raw === 'both' ? allowed.slice() : [...new Set(raw.split(',').filter(Boolean))];

            const invalid = req.filter(t => !allowed.includes(t));
            if (invalid.length) { core.setFailed(`Unknown tenant(s): ${invalid.join(', ')}. Allowed: ${allowed.join(', ')}`); return; }

            const ch = process.env.CH;
            // Business rule: staging+csu is forbidden
            if (ch === 'staging' && req.includes('csu')) {
              core.setFailed(`Promotion blocked: 'csu' is not deployed on 'staging'.`);
              return;
            }

            req.sort();
            core.info(`Allowed: ${allowed.join(', ')}`);
            core.info(`Requested: ${req.join(', ')}`);
            core.setOutput('csv', req.join(','));
        env:
          RAW_TENANTS: ${{ env.RAW_TENANTS }}

      # Resolve source SHA from an existing tag in this channel/version (prefer default, else any)
      - name: Resolve source tag SHA
        id: source
        shell: bash
        run: |
          set -euo pipefail
          CH="${CH}"
          VER="${VER}"

          if git rev-parse -q --verify "refs/tags/release/${CH}/default/${VER}" >/dev/null; then
            TAG="release/${CH}/default/${VER}"
          else
            TAG="$(git tag -l "release/${CH}/*/${VER}" | head -n1 || true)"
          fi

          if [[ -z "${TAG}" ]]; then
            echo "::error::No tag found for version ${VER} in channel ${CH}."
            echo "Looked for: release/${CH}/default/${VER} or release/${CH}/*/${VER}"
            exit 1
          fi

          SHA="$(git rev-list -n1 "${TAG}")"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "sha=${SHA}" >> "$GITHUB_OUTPUT"
          echo "Found ${TAG} -> ${SHA}"

      # Abort if ANY requested tenant already has this channel/version tag
      - name: Abort if tenant tag already exists
        id: precheck
        uses: actions/github-script@v7
        with:
          script: |
            const ch = process.env.CH, ver = process.env.VER;
            const tenants = '${{ steps.tenants.outputs.csv }}'.split(',').filter(Boolean);
            const owner = context.repo.owner, repo = context.repo.repo;

            const existing = [];
            for (const t of tenants) {
              const ref = `tags/release/${ch}/${t}/${ver}`;
              try {
                await github.rest.git.getRef({ owner, repo, ref });
                existing.push(t);
              } catch (e) {
                if (e.status !== 404) throw e;
              }
            }
            if (existing.length) {
              core.setFailed(`Aborting: tag(s) already exist for ${ch}/${ver} -> tenants [${existing.join(', ')}].`);
              return;
            }
            core.setOutput('ok','true');

      # Ensure requested tenant tags are created at the source SHA (atomic create)
      - name: Create tenant tags
        if: steps.precheck.outputs.ok == 'true'
        id: create_tags
        uses: actions/github-script@v7
        with:
          script: |
            const ch = process.env.CH, ver = process.env.VER;
            const sha = '${{ steps.source.outputs.sha }}';
            const tenants = '${{ steps.tenants.outputs.csv }}'.split(',').filter(Boolean);
            const owner = context.repo.owner, repo = context.repo.repo;
            for (const t of tenants) {
              const tag = `release/${ch}/${t}/${ver}`;
              await github.rest.git.createRef({ owner, repo, ref: `refs/tags/${tag}`, sha });
              core.info(`Created tag ${tag} at ${sha}`);
            }
            core.setOutput('csv', tenants.join(','));

      # Ensure a single canonical release for this channel/version exists, then upsert tenant sections
      - name: Ensure GitHub Release (canonical)
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            const ch    = process.env.CH;
            const ver   = process.env.VER;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            async function getRelease(tag){
              try { return await github.rest.repos.getReleaseByTag({ owner, repo, tag }); }
              catch(e){ if (e.status===404) return null; throw e; }
            }

            let canonicalTag = `release/${ch}/default/${ver}`;
            let rel = await getRelease(canonicalTag);

            if (!rel) {
              const { data: refs } = await github.rest.git.listMatchingRefs({ owner, repo, ref: `tags/release/${ch}/` });
              const candidates = refs.map(r => r.ref.replace('refs/tags/','')).filter(ref => ref.endsWith(`/${ver}`));
              for (const tag of candidates) {
                const r = await getRelease(tag);
                if (r) { canonicalTag = tag; rel = r; break; }
              }
            }

            if (!rel) { core.setFailed(`No existing GitHub Release for ${ch} ${ver}. Create via merge workflow first.`); return; }
            core.info(`Using existing release: ${canonicalTag}`);
            core.setOutput('release_tag', canonicalTag);
            core.setOutput('release_id', (rel.data ? rel.data.id : rel.id));

      # Upsert per-tenant delta in release notes (with tenant compare link)
      - name: Upsert per-tenant section(s)
        if: steps.precheck.outputs.ok == 'true'
        id: upsert
        uses: actions/github-script@v7
        with:
          script: |
            const ch      = process.env.CH;
            const ver     = process.env.VER;
            const owner   = context.repo.owner;
            const repo    = context.repo.repo;
            const tenants = '${{ steps.create_tags.outputs.csv }}'.split(',').filter(Boolean);
            const canonicalTag = '${{ steps.release.outputs.release_tag }}';
            const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag: canonicalTag });
            let body = rel.data.body || '';

            function semverCmp(a,b){const pa=a.split('.').map(Number),pb=b.split('.').map(Number);for(let i=0;i<3;i++){if((pa[i]||0)<(pb[i]||0))return-1;if((pa[i]||0)>(pb[i]||0))return 1}return 0}
            const semverLess=(a,b)=>semverCmp(a,b)<0;

            async function prevTagForTenant(t){
              const prefix = `tags/release/${ch}/${t}/`;
              const { data: refs } = await github.rest.git.listMatchingRefs({ owner, repo, ref: prefix });
              const versions = refs.map(r=>r.ref.split('/').pop()).filter(v=>v && v!==ver).sort(semverCmp);
              const prev = versions.filter(v=>semverLess(v,ver)).pop();
              return prev ? `release/${ch}/${t}/${prev}` : null;
            }

            function upsertSection(b, key, content){
              const start = `<!-- BEGIN:${key} -->`, end = `<!-- END:${key} -->`;
              const block = `${start}\n${content}\n${end}`;
              const re = new RegExp(`${start}[\\s\\S]*?${end}`,'m');
              return re.test(b) ? b.replace(re, block) : `${b.trim()}\n\n${block}\n`;
            }

            const sections = {};
            for (const t of tenants) {
              const prevTag = await prevTagForTenant(t);
              const newTag  = `release/${ch}/${t}/${ver}`;

              let content;
              if (!prevTag) {
                content = `### ${t.toUpperCase()} changes\n_No previous tag found in \`release/${ch}/${t}/\`._`;
              } else {
                const cmp = await github.rest.repos.compareCommitsWithBasehead({ owner, repo, basehead: `${prevTag}...${newTag}` });
                const compareUrl = cmp.data.html_url || `https://github.com/${owner}/${repo}/compare/${prevTag}...${newTag}`;
                const lines = (cmp.data.commits||[]).map(c=>{
                  const title=(c.commit?.message||'').split('\n')[0];
                  const sha=(c.sha||'').slice(0,7);
                  return `- ${title} (${sha})`;
                });
                content = `### [${t.toUpperCase()} changes](${compareUrl})\n_From **${prevTag.split('/').pop()}** to **${ver}**_:\n\n${lines.length ? lines.join('\n') : '_No changes_'}`;
              }

              // persist section + mapping (even when no prevTag)
              body = upsertSection(body, `tenant:${ch}:${t}:${ver}`, content);
              sections[t] = { prevTag: prevTag || null, newTag };
            }

            await github.rest.repos.updateRelease({ owner, repo, release_id: rel.data.id, body });
            core.setOutput('sections', JSON.stringify(sections));

      # Build + upload manifest.json as release asset (replace if exists)
      - name: Create & upload manifest.json
        if: steps.precheck.outputs.ok == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs'), path = require('path');
            const owner = context.repo.owner, repo = context.repo.repo;

            const ch     = process.env.CH;
            const ver    = process.env.VER;
            const sha    = '${{ steps.source.outputs.sha }}';
            const relTag = '${{ steps.release.outputs.release_tag }}';
            const sections = JSON.parse('${{ steps.upsert.outputs.sections}}');

            // Create manifest object
            const manifest = {
              channel: ch,
              version: ver,
              sha,
              tenants: Object.fromEntries(
                Object.entries(sections).map(([t, s]) => [t, { tag: s.newTag, previous: s.prevTag }])
              ),
              links: Object.fromEntries(
                Object.entries(sections).map(([t, s]) => [
                  t,
                  s.prevTag ? `https://github.com/${owner}/${repo}/compare/${s.prevTag}...${s.newTag}` : null
                ])
              ),
              release_tag: relTag,
              created_at: new Date().toISOString(),
              created_by: context.actor
            };

            const outDir = path.join(process.env.GITHUB_WORKSPACE, '.out');
            fs.mkdirSync(outDir, { recursive: true });
            const file = path.join(outDir, 'manifest.json');
            fs.writeFileSync(file, JSON.stringify(manifest, null, 2), 'utf8');
            core.info(`Wrote ${file}`);
            core.setOutput('file', file);

            // Upload (replace if exists)
            const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag: relTag });
            const rid = rel.data.id;

            const assets = await github.rest.repos.listReleaseAssets({ owner, repo, release_id: rid });
            const existing = assets.data.find(a => a.name === 'manifest.json');
            if (existing) {
              await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: existing.id });
              core.info('Deleted existing manifest.json asset');
            }

            const headers = { 'content-type': 'application/json', 'content-length': fs.statSync(file).size };
            await github.rest.repos.uploadReleaseAsset({
              owner, repo, release_id: rid, name: 'manifest.json', headers, data: fs.createReadStream(file)
            });
            core.info('Uploaded manifest.json')
