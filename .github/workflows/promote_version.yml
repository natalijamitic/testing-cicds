name: Promote existing version (copy tags across tenants/envs)

on:
  workflow_dispatch:
    inputs:
      from_channel:
        description: "Source env"
        type: choice
        options: [dev, staging, production]
        default: dev
      to_channel:
        description: "Target env"
        type: choice
        options: [dev, staging, production]
        default: staging
      version:
        description: "X.Y.Z to promote (must exist in source)"
        type: string
        required: true
      tenants:
        description: "Comma-separated tenants (e.g., csu or default,csu or 'both')"
        type: string
        default: "csu"

permissions:
  contents: write

jobs:
  promote:
    runs-on: ubuntu-latest
    concurrency:
      group: promote-${{ inputs.from_channel }}-${{ inputs.to_channel }}
      cancel-in-progress: false

    env:
      FROM: ${{ inputs.from_channel }}
      TO: ${{ inputs.to_channel }}
      VER: ${{ inputs.version }}
      RAW_TENANTS: ${{ inputs.tenants }}

    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Fetch all refs
        run: git fetch --all --tags --force --quiet

      # Load tenants allow-list from .github/tenants.json and validate input (supports 'both')
      - name: Validate tenants (single source of truth)
        id: tenants
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const cfg = path.join(process.env.GITHUB_WORKSPACE,'.github','tenants.json');
            if (!fs.existsSync(cfg)) { core.setFailed(`Missing ${cfg}`); return; }
            const {tenants: allowed} = JSON.parse(fs.readFileSync(cfg,'utf8'));
            const raw = (process.env.RAW_TENANTS||'').replace(/\s+/g,'').toLowerCase();
            if (!raw) { core.setFailed('No tenants provided'); return; }

            let req;
            if (raw === 'both') req = allowed.slice();
            else req = [...new Set(raw.split(',').filter(Boolean))];

            const invalid = req.filter(t => !allowed.includes(t));
            if (invalid.length) { core.setFailed(`Unknown tenant(s): ${invalid.join(', ')}. Allowed: ${allowed.join(', ')}`); return; }

            core.info(`Allowed: ${allowed.join(', ')}`);
            core.info(`Requested: ${req.join(', ')}`);
            core.setOutput('csv', req.join(','));
        env:
          RAW_TENANTS: ${{ env.RAW_TENANTS }}

      # Resolve the source SHA by reading any existing tag at release/<FROM>/<tenant>/<VER>
      # Prefer default tenant if present; fallback to any tenant that has that version.
      - name: Resolve source tag SHA
        id: source
        shell: bash
        run: |
          set -euo pipefail
          FROM="${FROM}"
          VER="${VER}"

          # Try default first for determinism
          if git rev-parse -q --verify "refs/tags/release/${FROM}/default/${VER}" >/dev/null; then
            TAG="release/${FROM}/default/${VER}"
          else
            # Search all tenants in source channel for the version
            TAG="$(git tag -l "release/${FROM}/*/${VER}" | head -n1 || true)"
          fi

          if [[ -z "${TAG}" ]]; then
            echo "::error::No tag found for version ${VER} in channel ${FROM}."
            echo "Looked for: release/${FROM}/default/${VER} or release/${FROM}/*/${VER}"
            exit 1
          fi

          SHA="$(git rev-list -n1 "${TAG}")"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "sha=${SHA}" >> "$GITHUB_OUTPUT"
          echo "Found ${TAG} -> ${SHA}"

      # Create tags in the target channel at the same SHA for each requested tenant
      - name: Create/verify target tags
        id: tags
        uses: actions/github-script@v7
        with:
          script: |
            const to    = process.env.TO;
            const ver   = process.env.VER;
            const sha   = '${{ steps.source.outputs.sha }}';
            const tenants = '${{ steps.tenants.outputs.csv }}'.split(',').filter(Boolean);
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            let any = false;
            for (const t of tenants) {
              const tag = `release/${to}/${t}/${ver}`;
              try {
                const ref = await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
                core.info(`Tag exists: ${tag} -> ${ref.data?.object?.sha}`);
                any = true;
              } catch (e) {
                if (e.status === 404) {
                  core.info(`Creating tag ${tag} at ${sha}`);
                  await github.rest.git.createRef({ owner, repo, ref: `refs/tags/${tag}`, sha });
                  any = true;
                } else {
                  core.warning(`Failed to check/create ${tag}: ${e.message}`);
                }
              }
            }
            core.setOutput('any', any ? 'true' : 'false');

      - name: Stop if no tags present
        if: steps.tags.outputs.any != 'true'
        run: echo "No target tags present â€” skipping GitHub Release."

      # Create or update the canonical GitHub Release for the target channel/version
      - name: Ensure GitHub Release (canonical)
        if: steps.tags.outputs.any == 'true'
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            const to    = process.env.TO;
            const ver   = process.env.VER;
            const tenants = '${{ steps.tenants.outputs.csv }}'.split(',').filter(Boolean);

            const canonicalTenant = tenants.includes('default') ? 'default' : (tenants[0] || 'default');
            const tagName = `release/${to}/${canonicalTenant}/${ver}`;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
              core.info(`Release exists for ${tagName}`);
            } catch (e) {
              if (e.status === 404) {
                core.info(`Creating release for ${tagName}`);
                release = await github.rest.repos.createRelease({
                  owner, repo,
                  tag_name: tagName,
                  name: `${to} ${ver}`,
                  generate_release_notes: true,
                  draft: false,
                  prerelease: to !== 'production'
                });
              } else { throw e; }
            }
            core.setOutput('release_id', (release.data ? release.data.id : release.id));
            core.setOutput('release_tag', tagName)

      # OPTIONAL: append per-tenant deltas for the target channel/version
      - name: Append per-tenant delta to release notes
        if: steps.tags.outputs.any == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const to      = process.env.TO;
            const ver     = process.env.VER;
            const owner   = context.repo.owner;
            const repo    = context.repo.repo;
            const tenants = '${{ steps.tenants.outputs.csv }}'.split(',').filter(Boolean);

            const canonicalTenant = tenants.includes('default') ? 'default' : (tenants[0] || 'default');
            const tagName = `release/${to}/${canonicalTenant}/${ver}`;
            const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
            let body = rel.data.body || '';

            function semverCmp(a,b){const pa=a.split('.').map(Number),pb=b.split('.').map(Number);for(let i=0;i<3;i++){if((pa[i]||0)<(pb[i]||0))return-1;if((pa[i]||0)>(pb[i]||0))return 1}return 0}
            const semverLess=(a,b)=>semverCmp(a,b)<0;

            async function prevTagForTenant(t){
              const prefix = `tags/release/${to}/${t}/`;
              const { data: refs } = await github.rest.git.listMatchingRefs({ owner, repo, ref: prefix });
              const versions = refs.map(r=>r.ref.split('/').pop()).filter(v=>v && v!==ver).sort(semverCmp);
              const prev = versions.filter(v=>semverLess(v,ver)).pop();
              return prev ? `release/${to}/${t}/${prev}` : null;
            }

            for (const t of tenants) {
              const prevTag = await prevTagForTenant(t);
              const newTag  = `release/${to}/${t}/${ver}`;
              if (!prevTag) {
                body += `\n\n### ${t.toUpperCase()} changes\n_No previous tag found in \`release/${to}/${t}/\`._`;
                continue;
              }
              const cmp = await github.rest.repos.compareCommitsWithBasehead({ owner, repo, basehead: `${prevTag}...${newTag}` });
              const lines = (cmp.data.commits||[]).map(c=>{
                const title=(c.commit?.message||'').split('\n')[0];
                const sha=(c.sha||'').slice(0,7);
                return `- ${title} (${sha})`;
              });
              body += `\n\n### ${t.toUpperCase()} changes\n_From **${prevTag.split('/').pop()}** to **${ver}**_\n` + (lines.length?lines.join('\n'):'_No changes_');
            }
            await github.rest.repos.updateRelease({ owner, repo, release_id: rel.data.id, body })
