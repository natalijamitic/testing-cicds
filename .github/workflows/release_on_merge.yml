name: Auto tag and release on merge to develop/staging/production

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: read

jobs:
  tag-on-merge:
    if: github.event.pull_request.merged == true &&
        (github.event.pull_request.base.ref == 'development' ||
         github.event.pull_request.base.ref == 'staging' ||
         github.event.pull_request.base.ref == 'production')
    runs-on: ubuntu-latest

    # Concurrency per channel so dev/staging/prod don't block each other
    concurrency:
      group: release-${{ github.event.pull_request.base.ref }}
      cancel-in-progress: false

    env:
      BASE_REF: ${{ github.event.pull_request.base.ref }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Resolve channel (dev|staging|production) from base branch
      - name: Resolve release channel
        id: channel
        run: |
          case "${BASE_REF}" in
            development)    CHANNEL="dev" ;;
            staging)    CHANNEL="staging" ;;
            production) CHANNEL="production" ;;
            *) echo "Unsupported base ref: ${BASE_REF}"; exit 1 ;;
          esac
          echo "channel=${CHANNEL}" >> "$GITHUB_OUTPUT"
          echo "CHANNEL=${CHANNEL}" >> "$GITHUB_ENV"

      # Parse labels → bump + tenants (your shared composite)
      - name: Derive labels (bump + tenants)
        id: labels
        uses: ./.github/actions/validate-release-labels
        with:
          enforce: "false"

      - name: Skip if invalid or skip=true
        id: guard
        run: |
          echo "invalid=${{ steps.labels.outputs.invalid }}" >> "$GITHUB_OUTPUT"
          echo "skip=${{ steps.labels.outputs.skip }}" >> "$GITHUB_OUTPUT"
          if [ "${{ steps.labels.outputs.invalid }}" = "true" ]; then
            echo "Invalid labeling: ${{ steps.labels.outputs.reason }} — skipping."
            exit 0
          fi
          if [ "${{ steps.labels.outputs.skip }}" = "true" ]; then
            echo "No-op (no release or release:none) — skipping."
            exit 0
          fi

      - name: Fetch tags
        if: steps.guard.outputs.skip != 'true' && steps.guard.outputs.invalid != 'true'
        run: git fetch --tags --force --quiet

      # Compute next SemVer within the current channel (dev|staging|production)
      - name: Compute next version
        if: steps.guard.outputs.skip != 'true' && steps.guard.outputs.invalid != 'true'
        id: semver
        shell: bash
        run: |
          set -euo pipefail
          BUMP="${{ steps.labels.outputs.bump }}"
          CH="${CHANNEL}"

          LATEST=$(
            git for-each-ref "refs/tags/release/${CH}/*/*" --format='%(refname:short)' \
            | awk -F'/' '{print $4}' \
            | sort -V \
            | tail -n1
          )
          if [[ -z "${LATEST}" ]]; then
            LATEST="0.0.0"
          fi

          IFS='.' read -r MA MI PA <<< "${LATEST}"

          case "$BUMP" in
            patch)  PA=$((PA+1)) ;;
            minor)  MI=$((MI+1)); PA=0 ;;
            major)  MA=$((MA+1)); MI=0; PA=0 ;;
            *) echo "Unknown bump: $BUMP"; exit 1 ;;
          esac

          NEXT="${MA}.${MI}.${PA}"
          echo "LATEST=${LATEST}"
          echo "next=${NEXT}" >> "$GITHUB_OUTPUT"

      # Create/verify tags for each tenant under the channel prefix
      - name: Create/verify tags for tenants
        if: steps.guard.outputs.skip != 'true' && steps.guard.outputs.invalid != 'true'
        id: tags
        uses: actions/github-script@v7
        with:
          script: |
            const channel  = process.env.CHANNEL; // dev|staging|production
            const next     = '${{ steps.semver.outputs.next }}';
            const mergeSha = context.payload.pull_request.merge_commit_sha;
            const tenants  = '${{ steps.labels.outputs.tenants }}'.split(',').filter(Boolean);
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            let any = false;
            for (const t of tenants) {
              const tag = `release/${channel}/${t}/${next}`;
              try {
                const ref = await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
                core.info(`Tag exists: ${tag} -> ${ref.data?.object?.sha}`);
                any = true;
              } catch (e) {
                if (e.status === 404) {
                  try {
                    core.info(`Creating tag ${tag} at ${mergeSha}`);
                    await github.rest.git.createRef({
                        owner, repo,
                        ref: `refs/tags/${tag}`,
                        sha: mergeSha
                    });
                    any = true;
                  } catch (err) {
                    core.warning(`Failed to create ${tag}: ${err.message}`);
                  }
                } else {
                  core.warning(`Failed to check ${tag}: ${e.message}`);
                }
              }
            }
            core.setOutput('any', any ? 'true' : 'false');

      - name: Stop if no tags exist/were created (collision or error)
        if: steps.tags.outputs.any != 'true'
        run: echo "No tenant tags present for this version — skipping GitHub Release."

      # Create ONE canonical GitHub Release for the channel (dev/staging/production)
      - name: Create canonical GitHub Release
        if: steps.tags.outputs.any == 'true'
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            const channel = process.env.CHANNEL; // dev|staging|production
            const next    = '${{ steps.semver.outputs.next }}';
            const tenantsCsv = '${{ steps.labels.outputs.tenants }}';
            const tenants = tenantsCsv.split(',').filter(Boolean).sort();

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Canonical tenant: prefer 'default' if present; else first tenant from labels
            const canonicalTenant = tenants.includes('default') ? 'default' : (tenants[0] || 'default');
            const tagName = `release/${channel}/${canonicalTenant}/${next}`;

            // Find previous tag for this canonical tenant
            function semverCmp(a,b){const pa=a.split('.').map(Number),pb=b.split('.').map(Number);for(let i=0;i<3;i++){if((pa[i]||0)<(pb[i]||0))return-1;if((pa[i]||0)>(pb[i]||0))return 1}return 0}
            const semverLess=(a,b)=>semverCmp(a,b)<0;

            const { data: refs } = await github.rest.git.listMatchingRefs({
              owner, repo, ref: `tags/release/${channel}/${canonicalTenant}/`
            });
            const versions = refs
              .map(r => r.ref.split('/').pop())
              .filter(v => v && v !== next)
              .sort(semverCmp);
            const prev = versions.filter(v => semverLess(v, next)).pop();
            const prevTagName = prev ? `release/${channel}/${canonicalTenant}/${prev}` : undefined;

            // Reuse or create release on the canonical tenant tag
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
              core.info(`Release for ${tagName} already exists.`);
            } catch (e) {
              if (e.status !== 404) throw e;

              // Generate notes relative to previous tag of the same tenant
              let body = '';
              try {
                const gen = await github.rest.repos.generateReleaseNotes({
                  owner, repo,
                  tag_name: tagName,
                  previous_tag_name: prevTagName,
                });
                body = gen.data.body || '';
              } catch (err) {
                core.warning(`generateReleaseNotes failed: ${err.message}`);
              }

              core.info(`Creating GitHub release for ${tagName}`);
              release = await github.rest.repos.createRelease({
                owner, repo,
                tag_name: tagName,
                name: `${channel} ${next}`,
                body,
                draft: false,
                prerelease: channel !== 'production'
              });
            }

            core.setOutput('release_id', (release.data ? release.data.id : release.id));
            core.setOutput('release_tag', tagName);

      # Append per-tenant deltas to the single channel release
      - name: Append per-tenant delta to release body
        if: steps.tags.outputs.any == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const channel = process.env.CHANNEL;
            const next    = '${{ steps.semver.outputs.next }}';
            const tenants = '${{ steps.labels.outputs.tenants }}'.split(',').filter(Boolean).sort();
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Use the exact canonical tag we created/reused above
            const canonicalTag = '${{ steps.release.outputs.release_tag }}';
            const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag: canonicalTag });
            let body = rel.data.body || '';

            function semverCmp(a, b) {
              const pa = a.split('.').map(Number);
              const pb = b.split('.').map(Number);
              for (let i = 0; i < 3; i++) {
                const da = pa[i] || 0, db = pb[i] || 0;
                if (da < db) return -1;
                if (da > db) return 1;
              }
              return 0;
            }
            const semverLess = (a, b) => semverCmp(a, b) < 0;

            async function findPrevTagForTenant(t) {
              const prefix = `tags/release/${channel}/${t}/`;
              const { data: refs } = await github.rest.git.listMatchingRefs({ owner, repo, ref: prefix });
              const versions = refs
                .map(r => r.ref.split('/').slice(-1)[0])
                .filter(v => v && v !== next)
                .sort(semverCmp);
              const prev = versions.filter(v => semverLess(v, next)).pop();
              return prev ? `release/${channel}/${t}/${prev}` : null;
            }

            // (Optional) helper to upsert a stable section per tenant to avoid duplicates
            function upsertSection(body, key, content) {
              const start = `<!-- BEGIN:${key} -->`;
              const end   = `<!-- END:${key} -->`;
              const block = `${start}\n${content}\n${end}`;
              const re = new RegExp(`${start}[\\s\\S]*?${end}`, 'm');
              return re.test(body) ? body.replace(re, block) : `${body.trim()}\n\n${block}\n`;
            }

            for (const t of tenants) {
              const prevTag = await findPrevTagForTenant(t);
              const newTag  = `release/${channel}/${t}/${next}`;

              if (!prevTag) {
                const content = `### ${t.toUpperCase()} changes\n_No previous tag found in \`release/${channel}/${t}/\`._`;
                body = upsertSection(body, `tenant:${channel}:${t}:${next}`, content);
                continue;
              }

              const compare = await github.rest.repos.compareCommitsWithBasehead({
                owner, repo, basehead: `${prevTag}...${newTag}`
              });

              const compareUrl = compare.data.html_url || `https://github.com/${owner}/${repo}/compare/${prevTag}...${newTag}`;
              const lines = (compare.data.commits || []).map(c => {
                const title = (c.commit?.message || '').split('\n')[0];
                const sha = (c.sha || '').slice(0,7);
                return `- ${title} (${sha})`;
              });

              const content = `### [${t.toUpperCase()} changes](${compareUrl})\n_From **${prevTag.split('/').pop()}** to **${next}**_:\n\n${lines.length ? lines.join('\n') : '_No changes_'}`;
              body = upsertSection(body, `tenant:${channel}:${t}:${next}`, content);
            }

            await github.rest.repos.updateRelease({
              owner, repo,
              release_id: rel.data.id,
              body
            });
      
      # Create & upload manifest.json (replace if exists)
      - name: Create & upload manifest.json
        if: steps.tags.outputs.any == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const owner   = context.repo.owner;
            const repo    = context.repo.repo;

            const channel = process.env.CHANNEL;
            const version = '${{ steps.semver.outputs.next }}';
            const mergeSha = context.payload.pull_request.merge_commit_sha;
            const tenants = '${{ steps.labels.outputs.tenants }}'.split(',').filter(Boolean).sort();

            const canonicalTag = '${{ steps.release.outputs.release_tag }}';

            function semverCmp(a,b){const pa=a.split('.').map(Number),pb=b.split('.').map(Number);for(let i=0;i<3;i++){if((pa[i]||0)<(pb[i]||0))return-1;if((pa[i]||0)>(pb[i]||0))return 1}return 0}
            const semverLess=(a,b)=>semverCmp(a,b)<0;

            async function prevTagForTenant(t){
              const prefix = `tags/release/${channel}/${t}/`;
              const { data: refs } = await github.rest.git.listMatchingRefs({ owner, repo, ref: prefix });
              const versions = refs.map(r=>r.ref.split('/').pop()).filter(v=>v && v!==version).sort(semverCmp);
              const prev = versions.filter(v=>semverLess(v,version)).pop();
              return prev ? `release/${channel}/${t}/${prev}` : null;
            }

            // Build sections for manifest: per-tenant tag + previous + compare link
            const tenantsObj = {};
            const linksObj   = {};
            for (const t of tenants) {
              const newTag  = `release/${channel}/${t}/${version}`;
              const prevTag = await prevTagForTenant(t);
              tenantsObj[t] = { tag: newTag, previous: prevTag };
              linksObj[t]   = prevTag
                ? `https://github.com/${owner}/${repo}/compare/${prevTag}...${newTag}`
                : null;
            }

            const manifest = {
              channel,
              version,
              sha: mergeSha,
              release_tag: canonicalTag,
              tenants: tenantsObj,
              links: linksObj,
              created_at: new Date().toISOString(),
              created_by: context.actor
              // Optionally add your artifact metadata here later (image digests, SBOM, etc.)
              // build: { image: "ghcr.io/…@sha256:…", sbom: "…" }
            };

            // Write to workspace
            const outDir = path.join(process.env.GITHUB_WORKSPACE, '.out');
            fs.mkdirSync(outDir, { recursive: true });
            const file = path.join(outDir, 'manifest.json');
            fs.writeFileSync(file, JSON.stringify(manifest, null, 2), 'utf8');
            core.info(`Wrote ${file}`);

            // Upload to the canonical release (replace if exists)
            const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag: canonicalTag });
            const release_id = rel.data.id;

            const assets = await github.rest.repos.listReleaseAssets({ owner, repo, release_id });
            const existing = assets.data.find(a => a.name === 'manifest.json');
            if (existing) {
              await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: existing.id });
              core.info('Deleted existing manifest.json asset');
            }

            const headers = { 'content-type': 'application/json', 'content-length': fs.statSync(file).size };
            await github.rest.repos.uploadReleaseAsset({
              owner, repo, release_id, name: 'manifest.json', headers, data: fs.createReadStream(file)
            });
            core.info('Uploaded manifest.json');


